远端mcu(ssh:root@10.35.146.7:22) <---> 加速器(运行turbo_relay) <---> 近端终端（ssh:root@10.35.146.109:10810）

python写测试脚本， 针对rtp和rtcp（主要是nack）

脚本尽量简单，流媒体数据都可以伪造，rtp和rtcp是完整的就可以
seq发送到65535时 seq回置为0

这个脚本是个多功能脚本，由参数指定
1. （必须）s/r   s=发送端  r=接收端
2.  h 不做任何事情，打印所有命令的意思，按发送端（s）参数和接收端（r）参数 分开显示


发送端（s）参数
1. （必须）-ip：对端ip   // 接收端可以通过接收后就知道对方ip了  不用指定
2. seq 发送的开始seq（以指定的seq开始发送rtp数据）（默认:0）
3. 发送端 可以指定多少概率丢包， 默认0（发送不丢包），比如： 5 （5%概率不发送这个rtp包， 模拟丢包了），rtcp不用模拟丢包
4. -t 数字： 发送rtp包的时间间隔， 默认20，即20ms
5. -k 数字： 数字 = 概率，5=%5，用延迟发送当前包来造成乱序，比如2个-t参数的时间，假设当前包间隔是20ms，那么我们延迟40ms发送包，  比如当前要发送一个包， 5%概率正好命中，那么这个包就开个线程，sleep 40ms后发送
6. x ： 开启nack响应， 对方发送nack过来，我们按照对方的seq再次创建一个对应seq的rtp包，发给对方  默认不开启（收到nack后不响应）


接收端（r）参数
1. -n 数字 ：开启nack发送（模拟发送nack重传rtp包），数字=概率， 比如5: 5%概率 要求重传当前包， 默认不发送nack



默认参数
1.rtp端口5544
2.rtcp端口5545

打印日志严格按我说的内容

发送端（s）
send [目标ip]  seq = xxx    // 正常发送一个包打印一次
--------lost-------seq=xxx  // 模拟丢包打印（该包不发送给对方）
+++daly send [目标ip]  seq = xxx    // 延迟发送包打印一次

接收端（r）
recv [目标ip]  seq = xxx [seq1 seq2 seq3...] // 收到包xxx， 【】中为未收到的包// 比如收到了4，5，8， 那么6，7就是未收到的包，一旦后面收到了，就删除，这里要注意，比如： 4，7，5，6，8，这种乱序，7是前面就收到了的，不要看到6，8，就认为7丢了



备注：
1. 注意seq回环， 比如 65534，1，0，2，3，65535

