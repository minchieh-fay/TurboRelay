我们要建立我们的rtp包
和net包一样接口和实现分离

在forwardPackets函数中，在writePacket之前

我们要把包劫持， 类型是udp包，并且是否是近端的包的bool值，给到rtp库进行分析

判断是不是  rtp， 是不是rtcp
不是就直接返回  需要发送的标识，直接return

如果是rtp或者rtcp，进入rtp的业务处理

用map存储 [ssrc][rtp信息（源ip 端口，源mac地址， 目标ip， 目标端口，目标mac地址）+rtcp信息（源ip 端口，源mac地址， 目标ip， 目标端口，目标mac地址）最后通讯时间戳等]

函数返回中带 这个packet是不是要发出去的标识
这样后面调用writePacket的时候 判断下， 有些包是没必要发出去的

场景：
1.近端收到的包 源头是if1过来的包
（认为过程中不会丢包， 直链的嘛）
记录信息， 缓存个100-500ms的rtp数据包
近端收到的包  全部需要发给对端， 发给对端（mcu）可能会丢包， 丢包我们在下面处理

2.远端收到的包 源头是if2过来的包
（认为mcu发过来的包  由于路径很长， 可能会丢包）
记录信息， 缓存rtp数据包，进行排序（注意 seq达到65535后 又要变成0的哦，这个seq =0 是跟在65535后面的）
只要顺序对的，我们就直接发流给if1
如果排序后丢包了，也可能乱序了， 我们sleep 10-50ms后， 如果包还没来， 我们就发送nack到if2 （向mcu补偿）
nack是走rtcp的， 如果原先的信息记录中有mcu的rtcp信息就用， 如果没有 我们只能按他的rtp的端口发送
2边的rtp和rtcp端口不一定一样， 清注意哈
如果if2过来的是nack， 那么我们刚吃在1中缓存的rtp包 按他需求重新发给if2


## rtp的发送接口是不是要暴露出来， 或者弄个回调函数给rtp， 这个你考虑



